<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker 基础入门 | ALAN</title><meta name="description" content="Docker 简介Docker 是什么简单地讲，可以将 Docker 容器理解为一种轻量级的沙盒（ sandbox）。 每个容器内运行着一个或多个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。 Docker 的好处"><meta name="keywords" content="docker 基础 入门 容器"><meta name="author" content="ALAN"><meta name="copyright" content="ALAN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Docker 基础入门"><meta name="twitter:description" content="Docker 简介Docker 是什么简单地讲，可以将 Docker 容器理解为一种轻量级的沙盒（ sandbox）。 每个容器内运行着一个或多个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。 Docker 的好处"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Docker 基础入门"><meta property="og:url" content="https://rocc.top/2019/10/01/Docker%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="ALAN"><meta property="og:description" content="Docker 简介Docker 是什么简单地讲，可以将 Docker 容器理解为一种轻量级的沙盒（ sandbox）。 每个容器内运行着一个或多个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。 Docker 的好处"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-10-01T15:55:50.000Z"><meta property="article:modified_time" content="2020-06-17T06:19:02.392Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://rocc.top/2019/10/01/Docker%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"><link rel="prev" title="二进制部署 kubernetes 集群" href="https://rocc.top/2020/01/01/Kubernetes%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/"><link rel="next" title="Python 基础入门" href="https://rocc.top/2019/03/20/Python%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://rocc.top/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/cc-001.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="https://download.rocc.top" target="_blank" rel="noopener"><i class="fa-fw fa fa-download"></i><span> Download</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-简介"><span class="toc-number">1.</span> <span class="toc-text">Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-是什么"><span class="toc-number">1.0.1.</span> <span class="toc-text">Docker 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-的好处"><span class="toc-number">1.0.2.</span> <span class="toc-text">Docker 的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-在开发和运维中的优势"><span class="toc-number">1.0.3.</span> <span class="toc-text">Docker 在开发和运维中的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-核心概念"><span class="toc-number">1.0.4.</span> <span class="toc-text">Docker 核心概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装-Docker-引擎"><span class="toc-number">2.</span> <span class="toc-text">安装 Docker 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Centos-7-环境下安装-Docker"><span class="toc-number">2.1.</span> <span class="toc-text">Centos 7 环境下安装 Docker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本的-Docker-镜像和容器管理命令"><span class="toc-number">3.</span> <span class="toc-text">基本的 Docker 镜像和容器管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#搜索-docker-hub-仓库中的镜像"><span class="toc-number">3.0.1.</span> <span class="toc-text">搜索 docker hub 仓库中的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取指定版本的镜像"><span class="toc-number">3.0.2.</span> <span class="toc-text">获取指定版本的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看已下载的镜像"><span class="toc-number">3.0.3.</span> <span class="toc-text">查看已下载的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除已下载的镜像"><span class="toc-number">3.0.4.</span> <span class="toc-text">删除已下载的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行一个-Nginx-容器"><span class="toc-number">3.0.5.</span> <span class="toc-text">运行一个 Nginx 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看所有运行中的容器"><span class="toc-number">3.0.6.</span> <span class="toc-text">查看所有运行中的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器详细信息（容器-Id-创建时间、路径、状态、镜像、配置等）"><span class="toc-number">3.0.7.</span> <span class="toc-text">查看容器详细信息（容器 Id 创建时间、路径、状态、镜像、配置等）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器日志"><span class="toc-number">3.0.8.</span> <span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器（在宿主机上的）进程"><span class="toc-number">3.0.9.</span> <span class="toc-text">查看容器（在宿主机上的）进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#显示-CPU-、内存、存储、网络等使用情况的统计信息"><span class="toc-number">3.0.10.</span> <span class="toc-text">显示 CPU 、内存、存储、网络等使用情况的统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制本地文件到容器"><span class="toc-number">3.0.11.</span> <span class="toc-text">复制本地文件到容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器内的数据变更情况"><span class="toc-number">3.0.12.</span> <span class="toc-text">查看容器内的数据变更情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器的端口映射"><span class="toc-number">3.0.13.</span> <span class="toc-text">查看容器的端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问容器内部系统"><span class="toc-number">3.0.14.</span> <span class="toc-text">访问容器内部系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新容器运行时的配置"><span class="toc-number">3.0.15.</span> <span class="toc-text">更新容器运行时的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止容器"><span class="toc-number">3.0.16.</span> <span class="toc-text">停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动容器"><span class="toc-number">3.0.17.</span> <span class="toc-text">启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重启容器"><span class="toc-number">3.0.18.</span> <span class="toc-text">重启容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除容器"><span class="toc-number">3.0.19.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建镜像-dockerfile"><span class="toc-number">3.0.20.</span> <span class="toc-text">构建镜像(dockerfile)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导出容器"><span class="toc-number">3.0.21.</span> <span class="toc-text">导出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导入容器"><span class="toc-number">3.0.22.</span> <span class="toc-text">导入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建镜像-根据容器"><span class="toc-number">3.0.23.</span> <span class="toc-text">创建镜像(根据容器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存镜像（生成镜像包文件）"><span class="toc-number">3.0.24.</span> <span class="toc-text">保存镜像（生成镜像包文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#载入镜像（导入镜像包文件）"><span class="toc-number">3.0.25.</span> <span class="toc-text">载入镜像（导入镜像包文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记镜像"><span class="toc-number">3.0.26.</span> <span class="toc-text">标记镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搭建-Docker-私有仓库"><span class="toc-number">4.</span> <span class="toc-text">搭建 Docker 私有仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-搭建私有-Docker-Registry"><span class="toc-number">4.1.</span> <span class="toc-text">1. 搭建私有 Docker Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一：使用-YUM-安装-docker-distribution"><span class="toc-number">4.1.1.</span> <span class="toc-text">方法一：使用 YUM 安装 docker-distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式二：使用容器运行"><span class="toc-number">4.1.2.</span> <span class="toc-text">方式二：使用容器运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决无法上传下载镜像（默认只支持-https-协议）的问题"><span class="toc-number">4.1.3.</span> <span class="toc-text">解决无法上传下载镜像（默认只支持 https 协议）的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上传镜像"><span class="toc-number">4.1.4.</span> <span class="toc-text">上传镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下载镜像"><span class="toc-number">4.1.5.</span> <span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看目前有哪些镜像"><span class="toc-number">4.1.6.</span> <span class="toc-text">查看目前有哪些镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-搭建私有仓库-Harbor"><span class="toc-number">4.2.</span> <span class="toc-text">2. 搭建私有仓库 Harbor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据卷管理"><span class="toc-number">5.</span> <span class="toc-text">数据卷管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建数据卷"><span class="toc-number">5.1.</span> <span class="toc-text">创建数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绑定数据卷"><span class="toc-number">5.2.</span> <span class="toc-text">绑定数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据卷容器"><span class="toc-number">5.3.</span> <span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用数据卷容器来迁移数据"><span class="toc-number">5.4.</span> <span class="toc-text">利用数据卷容器来迁移数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#备份"><span class="toc-number">5.4.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#恢复"><span class="toc-number">5.4.2.</span> <span class="toc-text">恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#端口映射与容器互联"><span class="toc-number">6.</span> <span class="toc-text">端口映射与容器互联</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-端口映射实现容器访问"><span class="toc-number">6.1.</span> <span class="toc-text">1. 端口映射实现容器访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机映射端口到内部容器开放的网络端口"><span class="toc-number">6.1.1.</span> <span class="toc-text">随机映射端口到内部容器开放的网络端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射到指定端口"><span class="toc-number">6.1.2.</span> <span class="toc-text">映射到指定端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射到指定地址的指定端口"><span class="toc-number">6.1.3.</span> <span class="toc-text">映射到指定地址的指定端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射到指定地址的随机端口"><span class="toc-number">6.1.4.</span> <span class="toc-text">映射到指定地址的随机端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射到指定地址的指定-udp-端口"><span class="toc-number">6.1.5.</span> <span class="toc-text">映射到指定地址的指定 udp 端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-容器互联"><span class="toc-number">6.2.</span> <span class="toc-text">2. 容器互联</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Dockerfile-创建镜像"><span class="toc-number">7.</span> <span class="toc-text">使用 Dockerfile 创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#指令说明"><span class="toc-number">7.1.</span> <span class="toc-text">指令说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ARG-定义创建镜像过程中使用的变量"><span class="toc-number">7.1.1.</span> <span class="toc-text">1. ARG 定义创建镜像过程中使用的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-FROM-指定创建镜像的基础镜像"><span class="toc-number">7.1.2.</span> <span class="toc-text">2. FROM 指定创建镜像的基础镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LABEL-为生成的镜像添加元数据标签信息"><span class="toc-number">7.1.3.</span> <span class="toc-text">3. LABEL 为生成的镜像添加元数据标签信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-EXPOSE-声明容器在运行时服务监听的端口"><span class="toc-number">7.1.4.</span> <span class="toc-text">4. EXPOSE 声明容器在运行时服务监听的端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ENV-指定环境变量"><span class="toc-number">7.1.5.</span> <span class="toc-text">5. ENV 指定环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ENTRYPOINT-指定镜像的默认入口命令"><span class="toc-number">7.1.6.</span> <span class="toc-text">6. ENTRYPOINT 指定镜像的默认入口命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-VOLUME-创建一个数据卷挂载点"><span class="toc-number">7.1.7.</span> <span class="toc-text">7. VOLUME 创建一个数据卷挂载点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-USER-指定构建镜像和运行容器时的用户和可选的用户组"><span class="toc-number">7.1.8.</span> <span class="toc-text">8. USER 指定构建镜像和运行容器时的用户和可选的用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-WORKDIR-指定工作目录"><span class="toc-number">7.1.9.</span> <span class="toc-text">9. WORKDIR 指定工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ONBUILD-当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令"><span class="toc-number">7.1.10.</span> <span class="toc-text">10. ONBUILD 当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-STOPSIGNAL-指定容器退出时所要被发送的系统调用信号"><span class="toc-number">7.1.11.</span> <span class="toc-text">11. STOPSIGNAL 指定容器退出时所要被发送的系统调用信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HEALTHCHECK-配置如何测试容器以检查其是否仍在工作"><span class="toc-number">7.1.12.</span> <span class="toc-text">12. HEALTHCHECK 配置如何测试容器以检查其是否仍在工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-SHELL-设置执行命令时所使用的默认-shell-类型"><span class="toc-number">7.1.13.</span> <span class="toc-text">13. SHELL 设置执行命令时所使用的默认 shell 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-RUN-运行指定命令"><span class="toc-number">7.1.14.</span> <span class="toc-text">14. RUN 运行指定命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-CMD-指定容器启动时默认执行的命令"><span class="toc-number">7.1.15.</span> <span class="toc-text">15. CMD 指定容器启动时默认执行的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ADD-添加内容到镜像"><span class="toc-number">7.1.16.</span> <span class="toc-text">16. ADD 添加内容到镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-COPY-复制内容到镜像"><span class="toc-number">7.1.17.</span> <span class="toc-text">17. COPY 复制内容到镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建镜像"><span class="toc-number">7.2.</span> <span class="toc-text">创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多步骤构建"><span class="toc-number">7.2.1.</span> <span class="toc-text">多步骤构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-最佳实践"><span class="toc-number">7.2.2.</span> <span class="toc-text">Dockerfile 最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统镜像添加-SSH-服务"><span class="toc-number">8.</span> <span class="toc-text">系统镜像添加 SSH 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ubuntu"><span class="toc-number">8.1.</span> <span class="toc-text">Ubuntu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创建-ubuntu-sshd-工作目录"><span class="toc-number">8.1.1.</span> <span class="toc-text">1. 创建 ubuntu_sshd 工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-配置-ssh-授权密钥文件"><span class="toc-number">8.1.2.</span> <span class="toc-text">2. 配置 ssh 授权密钥文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-编写-Dockerfile"><span class="toc-number">8.1.3.</span> <span class="toc-text">3. 编写 Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-创建镜像"><span class="toc-number">8.1.4.</span> <span class="toc-text">4. 创建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-运行容器"><span class="toc-number">8.1.5.</span> <span class="toc-text">5. 运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-连接测试"><span class="toc-number">8.1.6.</span> <span class="toc-text">6. 连接测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Centos"><span class="toc-number">8.2.</span> <span class="toc-text">Centos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创建-ubuntu-sshd-工作目录-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">1. 创建 ubuntu_sshd 工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-配置-ssh-授权密钥文件-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">2. 配置 ssh 授权密钥文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-编写-Dockerfile-1"><span class="toc-number">8.2.3.</span> <span class="toc-text">3. 编写 Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-创建镜像-1"><span class="toc-number">8.2.4.</span> <span class="toc-text">4. 创建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-运行容器-1"><span class="toc-number">8.2.5.</span> <span class="toc-text">5. 运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-连接测试-1"><span class="toc-number">8.2.6.</span> <span class="toc-text">6. 连接测试</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTiT97jtws6ahmVlozMvxB675jSM4aAvp5shhMP9NZNCpta8Ivh&amp;usqp=CAU)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ALAN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="https://download.rocc.top" target="_blank" rel="noopener"><i class="fa-fw fa fa-download"></i><span> Download</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Docker 基础入门</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2019-10-01 23:55:50"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-10-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-06-17 14:19:02"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-17</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><p>简单地讲，可以将 Docker 容器理解为一种轻量级的沙盒（ sandbox）。 每个容器内运行着一个或多个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。</p>
<h3 id="Docker-的好处"><a href="#Docker-的好处" class="headerlink" title="Docker 的好处"></a>Docker 的好处</h3><p>以服务器迁移为例，Docker 提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台。这无疑将帮助我们节约大量的宝贵时间，并降低部署过程出现问题的风险。</p>
<h3 id="Docker-在开发和运维中的优势"><a href="#Docker-在开发和运维中的优势" class="headerlink" title="Docker 在开发和运维中的优势"></a>Docker 在开发和运维中的优势</h3><ul>
<li><p>更快速的交付和部署</p>
<p>使用 Docker ，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p>
</li>
<li><p>更高效的资源利用</p>
<p>运行 Docker 容器不需要额外的虚拟化管理程序（ Virtual MachineManager, VMM ，以及 Hypervisor ）的支持， Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。与传统虚拟机方式相比， Docker 的性能要提高 1 ~ 2 个数量级。</p>
</li>
<li><p>更轻松的迁移和扩展</p>
<p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、 服务器等，同时支持主流的操作系统发行版本。这种兼容性让用户可以在不同平台之间轻松地迁移应用。</p>
</li>
<li><p>更简单的更新管理</p>
<p>使用 Dockerfile ，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
</li>
</ul>
<h3 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h3><ol>
<li>Docker 镜像</li>
</ol>
<p>Docker 镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。</p>
<p>例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了 Apache 应用程序（或用户需要的其他软件） 可以把它称为一个 Apache 镜像。</p>
<p>镜像是创建 Docker 容器的基础。</p>
<p>通过版本管理和增量的文件系统， Docker 提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并直接使用。</p>
<ol start="2">
<li>Docker 容器</li>
</ol>
<p>Docker 容器类似于一个轻量级的沙箱， Docker 利用容器来运行和隔离应用容器是从镜像创建的应用运行实例 它可以启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的。</p>
<p>可以把容器看作一个简易版的 Linux 系统环境（包括 root 用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。</p>
<p>镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。</p>
<ol start="3">
<li>Docker 仓库</li>
</ol>
<p>Docker 仓库类似于代码仓库，是 Docker 集中存放镜像文件的场所。</p>
<p>根据所存储的镜像公开分享与否， Docker 仓库可以分为公开仓库（Public ）和私有仓库（ Private ）两种形式。</p>
<p>目前，最大的公开仓库是官方提供的 Docker Hub ，其中存放着数量庞大的镜像供用户下国内不少云服务提供商（如腾讯云 阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问。</p>
<p>当然，用户如果不希望公开分享自己的镜像文件， Docker 也支持用户在本地网络内创建一个只能自己访问的私有仓库。</p>
<p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上 pull 下来就可以了。</p>
<h1 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h1><h2 id="Centos-7-环境下安装-Docker"><a href="#Centos-7-环境下安装-Docker" class="headerlink" title="Centos 7 环境下安装 Docker"></a>Centos 7 环境下安装 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载官方源</span></span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo &lt;https://download.docker.com/linux/centos/docker-ce.repo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为腾讯源</span></span><br><span class="line">sed -i <span class="string">'s+download.docker.com+mirrors.cloud.tencent.com/docker-ce+'</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># yum 安装</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker 并设置为开机自启</span></span><br><span class="line">systemctl start docker &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置腾讯云 docker 镜像加速</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">       <span class="string">"https://mirror.ccs.tencentyun.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>



<h1 id="基本的-Docker-镜像和容器管理命令"><a href="#基本的-Docker-镜像和容器管理命令" class="headerlink" title="基本的 Docker 镜像和容器管理命令"></a>基本的 Docker 镜像和容器管理命令</h1><h3 id="搜索-docker-hub-仓库中的镜像"><a href="#搜索-docker-hub-仓库中的镜像" class="headerlink" title="搜索 docker hub 仓库中的镜像"></a>搜索 docker hub 仓库中的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>

<p>docker search 镜像名称</p>
<p>-s 数值 ：只显示 STARS 达到指定 数值 以上的镜像。</p>
<h3 id="获取指定版本的镜像"><a href="#获取指定版本的镜像" class="headerlink" title="获取指定版本的镜像"></a>获取指定版本的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>

<p>docker pull 镜像名称：镜像版本</p>
<p>如果不添加镜像版本，默认会获取最新版本的镜像。</p>
<h3 id="查看已下载的镜像"><a href="#查看已下载的镜像" class="headerlink" title="查看已下载的镜像"></a>查看已下载的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>-q ：只显示镜像 ID</p>
<p>–no-trunc ：不截断内容显示，显示各个参数的全部信息</p>
<h3 id="删除已下载的镜像"><a href="#删除已下载的镜像" class="headerlink" title="删除已下载的镜像"></a>删除已下载的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx</span><br></pre></td></tr></table></figure>

<p>docker rmi ”镜像名称 或 镜像 ID“</p>
<p>如果有基于该镜像的容器，则需要先删除相关容器后，再进行删除镜像操作。</p>
<h3 id="运行一个-Nginx-容器"><a href="#运行一个-Nginx-容器" class="headerlink" title="运行一个 Nginx 容器"></a>运行一个 Nginx 容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 81:80 -v /docker/nginx:/usr/share/nginx/html --name web nginx</span><br></pre></td></tr></table></figure>

<p>docker run -d -p 宿主机端口：容器端口 -v 宿主机目录：容器目录 —name 容器别名 镜像名称</p>
<p>-d ：后台运行</p>
<p>-p ：宿主机端口：容器端口，将容器的某个端口映射到宿主机的某个端口</p>
<p>-v ：宿主机目录：容器目录，将容器的某个目录挂载到宿主机的某个目录</p>
<p>-e ：当启动容器时传递环境变量及其值</p>
<p>—name ：容器别名</p>
<p>—rm ：容器在终止后会立刻删除。—rm 和 -d 参数不能同时使用。</p>
<h3 id="查看所有运行中的容器"><a href="#查看所有运行中的容器" class="headerlink" title="查看所有运行中的容器"></a>查看所有运行中的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>-a ：查看所有容器</p>
<p>-q ：只显示容器 ID</p>
<p>–no-trunc ：不截断内容显示，显示各个参数的全部信息</p>
<h3 id="查看容器详细信息（容器-Id-创建时间、路径、状态、镜像、配置等）"><a href="#查看容器详细信息（容器-Id-创建时间、路径、状态、镜像、配置等）" class="headerlink" title="查看容器详细信息（容器 Id 创建时间、路径、状态、镜像、配置等）"></a>查看容器详细信息（容器 Id 创建时间、路径、状态、镜像、配置等）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 453cbf7a755a</span><br></pre></td></tr></table></figure>

<p>docker inspect ”容器 ID 或 容器别名”</p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs web</span><br></pre></td></tr></table></figure>

<p>docker logs “容器名称 或 容器 ID”</p>
<h3 id="查看容器（在宿主机上的）进程"><a href="#查看容器（在宿主机上的）进程" class="headerlink" title="查看容器（在宿主机上的）进程"></a>查看容器（在宿主机上的）进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top web</span><br></pre></td></tr></table></figure>

<p>docker top “容器名称 或 容器 ID”</p>
<h3 id="显示-CPU-、内存、存储、网络等使用情况的统计信息"><a href="#显示-CPU-、内存、存储、网络等使用情况的统计信息" class="headerlink" title="显示 CPU 、内存、存储、网络等使用情况的统计信息"></a>显示 CPU 、内存、存储、网络等使用情况的统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure>

<p>-a ：输出所有容器统计信息，默认仅在运行中</p>
<h3 id="复制本地文件到容器"><a href="#复制本地文件到容器" class="headerlink" title="复制本地文件到容器"></a>复制本地文件到容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp index.html modest_mendel:/usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>docker cp 本地文件 “容器 ID 或容器别名”:容器目标路径</p>
<p>－ a ：复制文件会带有原始的 uid/gid 信息</p>
<p>－ L ：当原路径为软连接时，默认只复制链接信息，使用该选项会复制链接的目标内容</p>
<h3 id="查看容器内的数据变更情况"><a href="#查看容器内的数据变更情况" class="headerlink" title="查看容器内的数据变更情况"></a>查看容器内的数据变更情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff modest_mendel</span><br></pre></td></tr></table></figure>

<p>docker diff  “容器 ID 或容器别名”</p>
<h3 id="查看容器的端口映射"><a href="#查看容器的端口映射" class="headerlink" title="查看容器的端口映射"></a>查看容器的端口映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port modest_mendel</span><br></pre></td></tr></table></figure>

<p>docker port “容器 ID 或容器别名”</p>
<h3 id="访问容器内部系统"><a href="#访问容器内部系统" class="headerlink" title="访问容器内部系统"></a>访问容器内部系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it web bash</span><br></pre></td></tr></table></figure>

<p>docker exec -it “容器 ID 或容器别名” “容器内部系统中的 shell”</p>
<h3 id="更新容器运行时的配置"><a href="#更新容器运行时的配置" class="headerlink" title="更新容器运行时的配置"></a>更新容器运行时的配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制总配额为 1 秒，容器 test 所占用时间为 10% </span></span><br><span class="line">docker update --cpu-quota 1000000 modest_mendel</span><br><span class="line">docker update --cpu-period 100000 modest_mendel</span><br></pre></td></tr></table></figure>

<p>－blkio-weight uintl6 ：更新块 IO 限制， 10 ~ 1000 ，默认值为 0，代表无限制；</p>
<p>－ cpu-period int ：限制 CPU 调度器 CFS (Completely Fair Scheduler ）使用时间，单位为微秒，最小 1000;</p>
<p>－ cpu-quota int ：限制 CPU 调度器 CFS 配额，单位为微秒，最小 1000;</p>
<p>－ cpu-rt period int ：限制 CPU 调度器的实时周期，单位为微秒;</p>
<p>－ cpu-rt runtime int ：限制 CPU 调度器的实时运行时，单位为微秒；</p>
<p>－ c, -cpu-shares int 限制 CPU 使用份额；</p>
<p>－ cpus decimal ：限制 CPU 个数；</p>
<p>－ cpuset-cpus string ：允许使用的 CPU 核，如 0-3, 0,1;</p>
<p>－ cpuset mems string ：允许使用的内存块，如 0-3, 0, 1;</p>
<p>－ kernel-memor bytes ：限制使用的内核内存；</p>
<p>－ m, -memory bytes ：限制使用的内存；</p>
<p>－memory-reservation bytes ：内存软限制；</p>
<p>－memory-swap bytes ：内存加上缓存区的限制，-1 表示为对缓冲区无限制；</p>
<p>－ restart string ：容器退出后的重启策略。</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop web</span><br></pre></td></tr></table></figure>

<p>docker stop “容器名称 或 容器 ID”</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start web</span><br></pre></td></tr></table></figure>

<p>docker start “容器名称 或 容器 ID”</p>
<h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart web</span><br></pre></td></tr></table></figure>

<p>docker restart “容器名称 或 容器 ID”</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm web</span><br></pre></td></tr></table></figure>

<p>docker rm “容器名称 或 容器 ID”</p>
<p>-f ：强制删除。rm 不能删除正在运行的容器，加上 -f 参数可强制删除正在运行的容器。</p>
<h3 id="构建镜像-dockerfile"><a href="#构建镜像-dockerfile" class="headerlink" title="构建镜像(dockerfile)"></a>构建镜像(dockerfile)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t wp:v1.0 .</span><br></pre></td></tr></table></figure>

<p>docker build -t 自定义镜像名称：版本  “Dockerfile 文件存放目录的路径”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 文件示例</span></span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line">LABEL version=<span class="string">"1.0"</span> maintainer=<span class="string">"docker user &lt;docker_user@github&gt;"</span></span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> Testing Dockerfile ... &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 2f41f4b4bed1 &gt; nginx-test-images.tar</span><br></pre></td></tr></table></figure>

<p>docker export “容器 ID 或 容器名称” &gt; 镜像包名称</p>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import - new-nginx-test:v1.1 &lt; nginx-test-images.tar</span><br></pre></td></tr></table></figure>

<p>docker import - 自定义镜像名称：版本 &lt; 镜像包</p>
<h3 id="创建镜像-根据容器"><a href="#创建镜像-根据容器" class="headerlink" title="创建镜像(根据容器)"></a>创建镜像(根据容器)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">"testing-001"</span> -a <span class="string">"Alan"</span> 9d0d402af82a <span class="built_in">test</span>-001:v1.0</span><br></pre></td></tr></table></figure>

<p>docker commit -m “提交信息” -a “作者” “容器 ID” “自定义镜像名称：版本”</p>
<p>-p ：提交时暂停容器运行。</p>
<p>-c ：提交的时候执行 Dockerfile 指令，包括 CMD ENTRYPOINT ENV  EXPOSE LABEL ONBUILD USER VOLUME WORKDIR 等；</p>
<h3 id="保存镜像（生成镜像包文件）"><a href="#保存镜像（生成镜像包文件）" class="headerlink" title="保存镜像（生成镜像包文件）"></a>保存镜像（生成镜像包文件）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个镜像保存为一个镜像包文件</span></span><br><span class="line">docker save 590c8328bda3 &gt; save-images-1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个镜像保存为一个镜像包文件</span></span><br><span class="line">docker save -o save-images-2.tar tomcat:latest new-nginx-test:v1.1</span><br></pre></td></tr></table></figure>

<p>docker save ”镜像 ID 或 镜像名称：版本“ &gt; 镜像包文件名称</p>
<p>docker save -o 镜像包文件名称 ”镜像 ID 或 镜像名称：版本“ ”镜像 ID 或 镜像名称：版本“ …</p>
<h3 id="载入镜像（导入镜像包文件）"><a href="#载入镜像（导入镜像包文件）" class="headerlink" title="载入镜像（导入镜像包文件）"></a>载入镜像（导入镜像包文件）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; save-images-1.tar</span><br></pre></td></tr></table></figure>

<p>docker load &lt; 镜像包文件</p>
<h3 id="标记镜像"><a href="#标记镜像" class="headerlink" title="标记镜像"></a>标记镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag wp:v1.0 10.0.2.3:5000/registry-images-test:v1.1</span><br></pre></td></tr></table></figure>

<p>docker tag ”源容器名称：版本“ ”标记后的容器名称：版本“</p>
<h1 id="搭建-Docker-私有仓库"><a href="#搭建-Docker-私有仓库" class="headerlink" title="搭建 Docker 私有仓库"></a>搭建 Docker 私有仓库</h1><h2 id="1-搭建私有-Docker-Registry"><a href="#1-搭建私有-Docker-Registry" class="headerlink" title="1. 搭建私有 Docker Registry"></a>1. 搭建私有 Docker Registry</h2><h3 id="方法一：使用-YUM-安装-docker-distribution"><a href="#方法一：使用-YUM-安装-docker-distribution" class="headerlink" title="方法一：使用 YUM 安装 docker-distribution"></a>方法一：使用 YUM 安装 docker-distribution</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-distribution -y</span><br><span class="line">systemctl start docker-distribution &amp;&amp; systemctl <span class="built_in">enable</span> docker-distribution</span><br></pre></td></tr></table></figure>

<h3 id="方式二：使用容器运行"><a href="#方式二：使用容器运行" class="headerlink" title="方式二：使用容器运行"></a>方式二：使用容器运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always --name registry -p 5000:5000 -v /var/lib/registry:/var/lib/registry -d registry</span><br></pre></td></tr></table></figure>

<h3 id="解决无法上传下载镜像（默认只支持-https-协议）的问题"><a href="#解决无法上传下载镜像（默认只支持-https-协议）的问题" class="headerlink" title="解决无法上传下载镜像（默认只支持 https 协议）的问题"></a>解决无法上传下载镜像（默认只支持 https 协议）的问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 docker daemon 文件并重启服务</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"registry-mirrors"</span>: [<span class="string">"&lt;https://mirror.ccs.tencentyun.com&gt;"</span>],</span><br><span class="line">   <span class="string">"insecure-registries"</span>: [<span class="string">"10.0.2.3:5000"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>加入 “insecure-registries”: [“10.0.2.3:5000”] 这项参数，可以理解为将此私有仓库认证为安全仓库。其他客户端需要上传镜像或者从此仓库下载镜像，也需要修改该客户端本地的 docker daemon 文件加入此参数并重启 docker 服务。</p>
<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需将要上传的镜像标记为指定的名称前缀，例如上传 tomcat 镜像</span></span><br><span class="line">docker tag busybox:latest 10.0.2.3:5000/busybox:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传指定镜像到私有仓库</span></span><br><span class="line">docker push 10.0.2.3:5000/busybox:v1.0</span><br></pre></td></tr></table></figure>

<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先删除原有的镜像，确保本地没有此镜像</span></span><br><span class="line">docker rmi 10.0.2.3:5000/busybox:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从私有仓库拉取指定的镜像</span></span><br><span class="line">docker pull 10.0.2.3:5000/busybox:v1.0</span><br></pre></td></tr></table></figure>

<h3 id="查看目前有哪些镜像"><a href="#查看目前有哪些镜像" class="headerlink" title="查看目前有哪些镜像"></a>查看目前有哪些镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/lib/registry/docker/registry/v2/repositories</span><br></pre></td></tr></table></figure>

<h2 id="2-搭建私有仓库-Harbor"><a href="#2-搭建私有仓库-Harbor" class="headerlink" title="2. 搭建私有仓库 Harbor"></a>2. 搭建私有仓库 Harbor</h2><p>待完善</p>
<h1 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h1><p>数据卷 (Data Volumes) 是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于 Linux 中的 mount 行为。</p>
<ul>
<li>数据卷可以在容器之间共享和重用，容器间传递数据变得高效与方便；</li>
<li>对数据卷内数据的修改会立刻生效，无论是容器内操作还是本地操作；</li>
<li>对数据卷的更新不影响镜像，解耦开应用和数据；</li>
<li>卷会一直存在，直到没有容器使用，可以安全地卸载它。</li>
</ul>
<h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create -d <span class="built_in">local</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>create ：Create a volume inspect ：Display detailed information on one or more volumes ls ：List volumes prune ：Remove all unused local volumes rm ：Remove one or more volumes</p>
<p>数据卷所在目录：/var/lib/docker/volumes/</p>
<h2 id="绑定数据卷"><a href="#绑定数据卷" class="headerlink" title="绑定数据卷"></a>绑定数据卷</h2><p>除了使用 volume 子命令来管理数据卷外，还可以在创建容器时将主机本地的任意路径挂载到容器内作为数据卷。</p>
<p>运行容器时可以使用 -mount 选项来使用数据卷，-mount 支持三种类型的数据卷：</p>
<ul>
<li>volume ：普通数据卷，映射到 /var/lib/docker/volumes/ 目录下；</li>
<li>bind ：绑定数据卷，映射到主机指定路径下；</li>
<li>tmpfs ：临时数据卷，只存在于内存中。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/www,destination=/usr/share/nginx/html nginx:latest</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">docker run -d --name web -v /www:/usr/share/nginx/html nginx:latest</span><br></pre></td></tr></table></figure>

<p>Docker 挂载数据卷的默认权限为可读可写(rw)，用户也可以通过 ro 指定为只读：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web -v /www:/usr/share/nginx/html:ro nginx:latest</span><br></pre></td></tr></table></figure>

<p>加上 :ro 后，在容器内就无法修改 挂载数据卷内 的数据了。</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，那么最简单的方式就是使用数据卷容器。数据卷容器也是一个容器，它的目的是专门提供数据卷给其他的容器挂载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /data --name data centos</span><br><span class="line"></span><br><span class="line">docker run -it --volumes-from data --name db01 centos</span><br><span class="line"></span><br><span class="line">docker run -it --volumes-from data --name db02 centos</span><br></pre></td></tr></table></figure>

<p>db01 和 db02 都挂载同一个数据卷到相同的 /data 目录。</p>
<p>使用 —volumes-from 参数所挂载数据卷的容器自身并不需要保持运行状态。</p>
<p>删除 data db01 db02 任意挂载的容器，数据卷并不会被删除。如果要将数据卷删除，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除与容器关联的数据卷。</p>
<h2 id="利用数据卷容器来迁移数据"><a href="#利用数据卷容器来迁移数据" class="headerlink" title="利用数据卷容器来迁移数据"></a>利用数据卷容器来迁移数据</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份 data 数据卷容器内的数据卷</span></span><br><span class="line">docker run --volumes-from data -v $(<span class="built_in">pwd</span>):/backup --name worker centos tar zcvf /backup/bak.tar /data</span><br></pre></td></tr></table></figure>

<ol>
<li>利用 centos 镜像创建一个容器 worker；</li>
<li>使用 —volumes-from data 参数让 worker 容器挂载 data 容器的数据卷；</li>
<li>使用 -v $(pwd):/backup 参数挂载本地当前目录到 worker 容器的 /backup 目录</li>
<li>worker 容器启动后，使用 tar zcvf /backup/bak.tar /data 命令将 /data 下的内容备份到 worker 容器的 /backup/bak.tar ，即宿主机的当前目录下。</li>
</ol>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from data -v $(<span class="built_in">pwd</span>):/backup centos tar xvf /backup/bak.tar -C /data</span><br></pre></td></tr></table></figure>



<h1 id="端口映射与容器互联"><a href="#端口映射与容器互联" class="headerlink" title="端口映射与容器互联"></a>端口映射与容器互联</h1><h2 id="1-端口映射实现容器访问"><a href="#1-端口映射实现容器访问" class="headerlink" title="1. 端口映射实现容器访问"></a>1. 端口映射实现容器访问</h2><h3 id="随机映射端口到内部容器开放的网络端口"><a href="#随机映射端口到内部容器开放的网络端口" class="headerlink" title="随机映射端口到内部容器开放的网络端口"></a>随机映射端口到内部容器开放的网络端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P nginx:latest</span><br></pre></td></tr></table></figure>

<p>0.0.0.0:32770-&gt;80/tcp</p>
<p>-P ：随机映射一个本机端口到 nginx 容器的 80 端口</p>
<h3 id="映射到指定端口"><a href="#映射到指定端口" class="headerlink" title="映射到指定端口"></a>映射到指定端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 2080:80 nginx:latest</span><br><span class="line">docker run -d -p 2001:80 -p 2002:443 nginx:latest</span><br></pre></td></tr></table></figure>

<p>0.0.0.0:2080-&gt;80/tcp</p>
<p>-p ：映射本地的 2080 端口到 nginx 容器的 80 端口</p>
<p>0.0.0.0:2001-&gt;80/tcp, 0.0.0.0:2002-&gt;443/tcp</p>
<p>-p ：分别映射本地的 2001 和 2002 端口到 nginx 容器的 80 和 443 端口</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:2003:80 nginx:latest</span><br></pre></td></tr></table></figure>

<p>127.0.0.1:2003-&gt;80/tcp</p>
<p>-p ：映射 127.0.0.1 地址的 2003 端口到 nginx 容器的 80 端口</p>
<h3 id="映射到指定地址的随机端口"><a href="#映射到指定地址的随机端口" class="headerlink" title="映射到指定地址的随机端口"></a>映射到指定地址的随机端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::80 nginx:latest</span><br></pre></td></tr></table></figure>

<p>127.0.0.1:32768-&gt;80/tcp</p>
<h3 id="映射到指定地址的指定-udp-端口"><a href="#映射到指定地址的指定-udp-端口" class="headerlink" title="映射到指定地址的指定 udp 端口"></a>映射到指定地址的指定 udp 端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:2004:80/udp nginx:latest</span><br></pre></td></tr></table></figure>

<p>80/tcp, 127.0.0.1:2004-&gt;80/udp</p>
<h2 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2. 容器互联"></a>2. 容器互联</h2><p>—link 参数可以让容器之间安全地进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建一个数据库容器</span></span><br><span class="line">docker run -d --name db -e MYSQL_ROOT_PASSWORD=linux mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个 web 容器</span></span><br><span class="line">docker run -d -p 1080:80 --name web --link db:db nginx:latest</span><br></pre></td></tr></table></figure>

<p>—link 参数格式为 —link name:alias ，其中 name 是要链接的容器名称，alias 是别名。</p>
<p>Docker 相当于在两个容器之间创建了一个通道，而不直接映射他们的端口到宿主机上。启动 db 容器的时候并没有使用 -p 和 -P 标记，从而避免了暴露数据库服务端口到外部网络。</p>
<p>Docker 通过两种方式为容器公开连接信息：</p>
<ul>
<li>更新环境变量</li>
<li>更新 /etc/hosts 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it web sh</span><br><span class="line"><span class="comment"># env</span></span><br><span class="line">DB_PORT_33060_TCP_ADDR=172.17.0.2</span><br><span class="line">HOSTNAME=bf5ac571974b</span><br><span class="line">DB_PORT=tcp://172.17.0.2:3306</span><br><span class="line">DB_PORT_3306_TCP=tcp://172.17.0.2:3306</span><br><span class="line">DB_PORT_33060_TCP_PORT=33060</span><br><span class="line">DB_ENV_MYSQL_VERSION=5.7.30-1debian10</span><br><span class="line">DB_PORT_33060_TCP_PROTO=tcp</span><br><span class="line">HOME=/root</span><br><span class="line">DB_NAME=/web/db</span><br><span class="line">PKG_RELEASE=1~buster</span><br><span class="line">DB_PORT_33060_TCP=tcp://172.17.0.2:33060</span><br><span class="line">TERM=xterm</span><br><span class="line">NGINX_VERSION=1.17.10</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">NJS_VERSION=0.3.9</span><br><span class="line">DB_ENV_MYSQL_MAJOR=5.7</span><br><span class="line">DB_PORT_3306_TCP_ADDR=172.17.0.2</span><br><span class="line">DB_ENV_MYSQL_ROOT_PASSWORD=linux</span><br><span class="line">PWD=/</span><br><span class="line">DB_ENV_GOSU_VERSION=1.12</span><br><span class="line">DB_PORT_3306_TCP_PORT=3306</span><br><span class="line">DB_PORT_3306_TCP_PROTO=tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.2	db 567c62f44e3d</span><br><span class="line">172.17.0.3	bf5ac571974b</span><br></pre></td></tr></table></figure>



<h1 id="使用-Dockerfile-创建镜像"><a href="#使用-Dockerfile-创建镜像" class="headerlink" title="使用 Dockerfile 创建镜像"></a>使用 Dockerfile 创建镜像</h1><p>Dockerfile 由一行一行的命令语句组成，并且支持以 # 开头的注释行。</p>
<p>一般而言，Dockerfile 主体内容分为四个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时的执行指令。</p>
<p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></p>
<h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><h3 id="1-ARG-定义创建镜像过程中使用的变量"><a href="#1-ARG-定义创建镜像过程中使用的变量" class="headerlink" title="1. ARG 定义创建镜像过程中使用的变量"></a>1. ARG 定义创建镜像过程中使用的变量</h3><p>ARG <name>[=<default value>]</default></name></p>
<p>在执行 docker build 时，可以通过 –build-arg <varname>=<value> 来为变量赋值。当镜像编译成功后，ARG 指定的变量将不再存在。</value></varname></p>
<p>Docker 内置了一些预定义的 ARG 变量，用户可以直接使用，无须在 Dockerfile 中声明。</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<h3 id="2-FROM-指定创建镜像的基础镜像"><a href="#2-FROM-指定创建镜像的基础镜像" class="headerlink" title="2. FROM 指定创建镜像的基础镜像"></a>2. FROM 指定创建镜像的基础镜像</h3><p>FROM [–platform=<platform>] <image> [AS <name>]</name></image></platform></p>
<p>FROM [–platform=<platform>] <image>[:<tag>] [AS <name>]</name></tag></image></platform></p>
<p>FROM [–platform=<platform>] <image>[@<digest>] [AS <name>]</name></digest></image></platform></p>
<p>Dockerfile 中的第一条指令必须是 FROM 指令（ARG 除外）。如果在同一个 Dockerfile 中创建多个镜像时，可以使用多个 FROM 指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG VERSION=latest</span><br><span class="line">FROM centos:<span class="variable">$&#123;VERSION&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-LABEL-为生成的镜像添加元数据标签信息"><a href="#3-LABEL-为生成的镜像添加元数据标签信息" class="headerlink" title="3. LABEL 为生成的镜像添加元数据标签信息"></a>3. LABEL 为生成的镜像添加元数据标签信息</h3><p>LABEL <key>=<value> <key>=<value> <key>=<value> …</value></key></value></key></value></key></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=<span class="string">"1.0.0"</span></span><br><span class="line">LABEL author=<span class="string">"alan@yahoo"</span> date=<span class="string">"2020-05-20"</span></span><br><span class="line">LABEL description=<span class="string">"This text illustrates \\</span></span><br><span class="line"><span class="string">that label-values can span multiple lines."</span></span><br></pre></td></tr></table></figure>

<h3 id="4-EXPOSE-声明容器在运行时服务监听的端口"><a href="#4-EXPOSE-声明容器在运行时服务监听的端口" class="headerlink" title="4. EXPOSE 声明容器在运行时服务监听的端口"></a>4. EXPOSE 声明容器在运行时服务监听的端口</h3><p>EXPOSE <port> [<port>/<protocol>…]</protocol></port></port></p>
<p>默认情况下，EXPOSE 假定协议为 TCP</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80 443</span><br><span class="line">EXPOSE 80/udp</span><br></pre></td></tr></table></figure>

<p>该指令只是起到声明的作用，并不会自动完成端口映射。在启动容器时可以使用 -P 参数完成映射。</p>
<h3 id="5-ENV-指定环境变量"><a href="#5-ENV-指定环境变量" class="headerlink" title="5. ENV 指定环境变量"></a>5. ENV 指定环境变量</h3><p>在构建阶段中所有后续指令的环境中使用，在镜像启动的容器中也会存在。</p>
<p>ENV <key> <value> 或者 ENV <key>=<value> …</value></key></value></key></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV myName=<span class="string">"John Doe"</span> myDog=Rex\\ The\\ Dog \\</span><br><span class="line">    myCat=fluffy</span><br><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br></pre></td></tr></table></figure>

<p>指令指定的环境变量在容器运行时可以被覆盖掉，如 docker run -e myName=Alan nginx:latest 。</p>
<p>使用 ENV 指令定义的环境变量，始终会覆盖 ARG 同名的变量。</p>
<p>当一条 ENV 指令中同时为多个环境变量赋值，并且值也是从环境变量中读取时，会为变量都赋值后再更新。如下指令，最终结果为 key1=value1 key2=value2 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV key1=value2</span><br><span class="line">ENV key1=value1 key2=<span class="variable">$&#123;key1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-ENTRYPOINT-指定镜像的默认入口命令"><a href="#6-ENTRYPOINT-指定镜像的默认入口命令" class="headerlink" title="6. ENTRYPOINT 指定镜像的默认入口命令"></a>6. ENTRYPOINT 指定镜像的默认入口命令</h3><p>该入口命令会在容器启动时作为根命令执行（pid 1 号进程），所有传入值作为该命令的参数。</p>
<p>支持两种格式：</p>
<p>ENTRYPOINT [“executable”, “param1”, “param2”]  ：exec 调用执行</p>
<p>ENTRYPOINT command param1 param2  ：shell 中执行</p>
<p>CMD 指令指定值将作为根命令的参数。</p>
<p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个生效。</p>
<p>在启动容器时，可以被 —entrypoint 参数覆盖掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span><br><span class="line">CMD [<span class="string">"-c"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="7-VOLUME-创建一个数据卷挂载点"><a href="#7-VOLUME-创建一个数据卷挂载点" class="headerlink" title="7. VOLUME 创建一个数据卷挂载点"></a>7. VOLUME 创建一个数据卷挂载点</h3><p>VOLUME /data 或者 VOLUME [“/data”]</p>
<p>运行容器时可以从本地主机或其它容器挂载数据卷，一般用于存放数据库和需要保持的数据等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir /myvol</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /myvol/greeting</span><br><span class="line">VOLUME /myvol</span><br></pre></td></tr></table></figure>

<h3 id="8-USER-指定构建镜像和运行容器时的用户和可选的用户组"><a href="#8-USER-指定构建镜像和运行容器时的用户和可选的用户组" class="headerlink" title="8. USER 指定构建镜像和运行容器时的用户和可选的用户组"></a>8. USER 指定构建镜像和运行容器时的用户和可选的用户组</h3><p>USER <user>[:<group>] 或者 USER <UID>[:<GID>]</GID></UID></group></user></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"><span class="comment"># Create Windows user in the container</span></span><br><span class="line">RUN net user /add patrick</span><br><span class="line"><span class="comment"># Set it for subsequent commands</span></span><br><span class="line">USER patrick</span><br></pre></td></tr></table></figure>

<p>docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。</p>
<h3 id="9-WORKDIR-指定工作目录"><a href="#9-WORKDIR-指定工作目录" class="headerlink" title="9. WORKDIR 指定工作目录"></a>9. WORKDIR 指定工作目录</h3><p>WORKDIR /path/to/workdir</p>
<p>Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。</p>
<p>该 WORKDIR 指令可以在中多次使用Dockerfile。如果提供了相对路径，则它将相对于上一条 WORKDIR 指令的路径 。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>最终的输出 pwd 命令结果将是 /a/b/c 。</p>
<p>使用 docker run 运行容器时，可以通过 -w 参数覆盖构建时所设置的工作目录。</p>
<h3 id="10-ONBUILD-当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令"><a href="#10-ONBUILD-当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令" class="headerlink" title="10. ONBUILD 当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令"></a>10. ONBUILD 当该镜像用作另一个构建的基础镜像时，将会自动执行的操作指令</h3><p>ONBUILD <INSTRUCTION></INSTRUCTION></p>
<p>当该镜像被作为 Dockerfile 中的基础镜像的时候，使用 docker build 构建镜像时，会首先执行基础镜像中配置的 ONBUILD 指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ONBUILD RUN mkdir /onbuild-testing</span><br><span class="line"><span class="comment"># 使用上述 Dockerfile 构建镜像后（镜像命名为 c1:latest），基于该镜像启动容器后并不会发现 /onbuild-testing 目录。</span></span><br><span class="line"></span><br><span class="line">FROM c1:latest</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /m</span><br><span class="line"><span class="comment"># 使用上述 Dockerfile 构建镜像后，发现 /onbuild-testing 目录存在。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-STOPSIGNAL-指定容器退出时所要被发送的系统调用信号"><a href="#11-STOPSIGNAL-指定容器退出时所要被发送的系统调用信号" class="headerlink" title="11. STOPSIGNAL 指定容器退出时所要被发送的系统调用信号"></a>11. STOPSIGNAL 指定容器退出时所要被发送的系统调用信号</h3><p>STOPSIGNAL signal</p>
<p>所使用的信号(signal)必须是内核系统调用表中的合法的值，如 SIGKILL 或 9 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kill -l</span></span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<h3 id="12-HEALTHCHECK-配置如何测试容器以检查其是否仍在工作"><a href="#12-HEALTHCHECK-配置如何测试容器以检查其是否仍在工作" class="headerlink" title="12. HEALTHCHECK 配置如何测试容器以检查其是否仍在工作"></a>12. HEALTHCHECK 配置如何测试容器以检查其是否仍在工作</h3><p>该 HEALTHCHECK 指令有两种形式：</p>
<ul>
<li>HEALTHCHECK [OPTIONS] CMD command （通过在容器内部运行命令来检查容器的运行状况）</li>
<li>HEALTHCHECK NONE （禁用从基础镜像中继承的任何运行状况检查）</li>
</ul>
<p>OPYIONS 支持如下参数：</p>
<ul>
<li><code>--interval=DURATION</code>（默认值：<code>30s</code>）每次检查后的间隔数秒</li>
<li><code>--timeout=DURATION</code>（默认值：<code>30s</code>）每次检查等待结果的超时时间</li>
<li><code>--start-period=DURATION</code>（默认值：<code>0s</code>）开始时间段为需要时间进行引导的容器提供了初始化时间。在此期间内的探针故障将不计入最大重试次数。但是，如果运行状况检查在启动期间成功，则认为该容器已启动，并且所有连续失败将计入最大重试次数。</li>
<li><code>--retries=N</code>（默认值：<code>3</code>）如果检测失败，需要重试几次才最终判定为失败</li>
</ul>
<h3 id="13-SHELL-设置执行命令时所使用的默认-shell-类型"><a href="#13-SHELL-设置执行命令时所使用的默认-shell-类型" class="headerlink" title="13. SHELL 设置执行命令时所使用的默认 shell 类型"></a>13. SHELL 设置执行命令时所使用的默认 shell 类型</h3><p>SHELL [“executable”, “parameters”]</p>
<p>Linux 上，默认值为 [“/bin/sh”, “-c”] 。</p>
<p>该 SHELL 指令可以出现多次。每个 SHELL 指令将覆盖所有先前的 SHELL 指令，并影响所有后续的指令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo default</span></span><br><span class="line">RUN <span class="built_in">echo</span> default</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C powershell -command Write-Host default</span></span><br><span class="line">RUN powershell -<span class="built_in">command</span> Write-Host default</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as powershell -command Write-Host hello</span></span><br><span class="line">SHELL [<span class="string">"powershell"</span>, <span class="string">"-command"</span>]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo hello</span></span><br><span class="line">SHELL [<span class="string">"cmd"</span>, <span class="string">"/S"</span>, <span class="string">"/C"</span>]</span><br><span class="line">RUN <span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure>

<h3 id="14-RUN-运行指定命令"><a href="#14-RUN-运行指定命令" class="headerlink" title="14. RUN 运行指定命令"></a>14. RUN 运行指定命令</h3><p>RUN <command> 或者 RUN [“executable”, “param1”, “param2”]</p>
<p>后者指令会被解析为 JSON 数组，因此必须使用双引号。</p>
<p>前者默认在 shell 终端中运行命令，即 /bin/sh -c ；后者则使用 exec 执行，不会启动 shell 环境。</p>
<p>指定使用其他终端类型也可以通过第二种方式实现，例如 RUN [“/bin/bash”,”-c”,”echo hello”] 。</p>
<p>每条 RUN 指令会在当前镜像基础上执行指定命令，并提交为新的镜像层。当命令较长时可以使用反斜杠 \ 换行。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c <span class="string">'source $HOME/.bashrc; \\</span></span><br><span class="line"><span class="string">echo $HOME'</span></span><br></pre></td></tr></table></figure>

<h3 id="15-CMD-指定容器启动时默认执行的命令"><a href="#15-CMD-指定容器启动时默认执行的命令" class="headerlink" title="15. CMD 指定容器启动时默认执行的命令"></a>15. CMD 指定容器启动时默认执行的命令</h3><p>该 CMD 指令具有三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>（<em>exec</em> 形式，推荐形式）</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>（作为 <em>ENTRYPOINT 的默认参数</em>）</li>
<li><code>CMD command param1 param2</code>（在默认的 shell 中执行）</li>
</ul>
<p>每个 Dockerfile 中只能有一条 CMD 指令。如果指定了多条，则只有最后一条会被执行。</p>
<p>如果在启动容器时手动指定了运行的命令（作为 run 命令的参数），则会覆盖掉 CMD 指定的命令。</p>
<h3 id="16-ADD-添加内容到镜像"><a href="#16-ADD-添加内容到镜像" class="headerlink" title="16. ADD 添加内容到镜像"></a>16. ADD 添加内容到镜像</h3><p>ADD [–chown=<user>:<group>] <src>… <dest></dest></src></group></user></p>
<p>ADD [–chown=<user>:<group>] [“<src>“,… “<dest>“]</dest></src></group></user></p>
<p>该命令将复制指定的 <src> 路径下的内容到镜像中的 <dest> 路径下。目标路径不存在时，会自动创建。</dest></src></p>
<p>其中 <src> 可以是 Dockerfile 所在目录的一个相对路径（文件或目录）；也可以是一个 URL；还可以是一个 tar 文件（将自动解压为目录）。<dest> 可以是镜像内的绝对路径，也可以是相对于工作目录（WORKDIR）的相对路径。</dest></src></p>
<p><src> 路径支持通配符，如 ADD hom* /mydir/ 。</src></p>
<h3 id="17-COPY-复制内容到镜像"><a href="#17-COPY-复制内容到镜像" class="headerlink" title="17. COPY 复制内容到镜像"></a>17. COPY 复制内容到镜像</h3><p>COPY [–chown=<user>:<group>] <src>… <dest> COPY [–chown=<user>:<group>] [“<src>“,… “<dest>“]</dest></src></group></user></dest></src></group></user></p>
<p>复制本地主机的 <src> 路径下的内容到镜像中的 <dest> 。目标路径不存在时，会自动创建。<src> 路径支持通配符。</src></dest></src></p>
<ul>
<li>该<code>&lt;src&gt;</code>路径必须在 Dockerfile 当前目录内; 不能跳出 Dockerfile 目录。例如：<code>COPY ../something /something</code> 将不能成功执行构建。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则将复制目录的整个内容，包括文件系统元数据。目录本身不被复制，仅其内容被复制。</li>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其及其元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾<code>/</code>，则将其视为目录，并将其内容<code>&lt;src&gt;</code>写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li>如果<code>&lt;src&gt;</code>直接或由于使用通配符而指定了多个资源，则该资源<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，则将其视为常规文件，并将其内容<code>&lt;src&gt;</code>写入<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，它将与路径中所有缺少的目录一起创建。</li>
</ul>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>可以通过 docker build 命令来创建镜像。</p>
<p>docker build [OPTIONS] PATH | URL | -</p>
<p>该命令将读取指定路径下的 Dockerfile，并将该路径下所有的数据作为上下文（Context）发送给 Docker 服务端。Docker 服务端校验 Dockerfile 格式通过后，逐条执行其中定义的指令，碰到 ADD、COPY 和 RUN 指令会生成一层镜像。最终如果创建镜像成功，会返回最终的镜像 ID 。</p>
<p>可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker 忽略匹配路径或文件，在创建镜像时不将无关的数据发送到服务端。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; .dockerignore &lt;&lt; EOF</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">tmp?</span><br><span class="line">~*</span><br><span class="line">Dockerfile</span><br><span class="line">!README.md</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ul>
<li>dockerignore 文件中模式语法支持 Golang 风格的路径正则格式</li>
<li><ul>
<li>表示任意多个字符</li>
</ul>
</li>
<li>？ 表示单个任意字符</li>
<li>！表示不匹配（即不忽略指定的路径或文件）</li>
</ul>
<h3 id="多步骤构建"><a href="#多步骤构建" class="headerlink" title="多步骤构建"></a>多步骤构建</h3><p>多步骤构建主要是为了解决一些在容器中进行编译工作，然后运行时容器只需要编译的结果，不需要整个编译环境被依赖，减少镜像的大小。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9 as builder <span class="comment"># define stage name as builder</span></span><br><span class="line">RUN mkdir -p /go/src/<span class="built_in">test</span></span><br><span class="line">WORKDIR /go/src/<span class="built_in">test</span></span><br><span class="line">COPY main.go</span><br><span class="line">RUN CGO_ENABLED=O GOOS=linux go build -o app</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk –no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY –from=builder /go/src/<span class="built_in">test</span>/app . <span class="comment"># copy file from the builder stage</span></span><br><span class="line">CMD [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a><strong>Dockerfile 最佳实践</strong></h3><ul>
<li>精简镜像用途</li>
<li>选择较小且合适的基础镜像（指定版本，禁用 latest）</li>
<li>提供注释和维护者信息</li>
<li>规范使用版本号</li>
<li>减少镜像层数</li>
<li>恰当使用多步骤构建</li>
<li>使用 .dockerignore 文件忽略不必要的数据内容</li>
<li>清空临时文件和缓存文件</li>
<li>调整合理的指令顺序（在开启 cache 的情况下，内容不变的指令尽量放在前面）</li>
<li>减少外部源干扰（如果要从外部引入数据，请指定持久的地址，并带版本信息等）</li>
</ul>
<h1 id="系统镜像添加-SSH-服务"><a href="#系统镜像添加-SSH-服务" class="headerlink" title="系统镜像添加 SSH 服务"></a>系统镜像添加 SSH 服务</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><h3 id="1-创建-ubuntu-sshd-工作目录"><a href="#1-创建-ubuntu-sshd-工作目录" class="headerlink" title="1. 创建 ubuntu_sshd 工作目录"></a>1. 创建 ubuntu_sshd 工作目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ubuntu-sshd</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$_</span></span><br></pre></td></tr></table></figure>

<h3 id="2-配置-ssh-授权密钥文件"><a href="#2-配置-ssh-授权密钥文件" class="headerlink" title="2. 配置 ssh 授权密钥文件"></a>2. 配置 ssh 授权密钥文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ -f ~/.ssh/id_rsa ] || ssh-keygen -t rsa -f ~/.ssh/id_rsa -N <span class="string">''</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt; authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="3-编写-Dockerfile"><a href="#3-编写-Dockerfile" class="headerlink" title="3. 编写 Dockerfile"></a>3. 编写 Dockerfile</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">LABEL version=<span class="string">"1.0.0"</span> author=<span class="string">"Alan"</span> date=<span class="string">"2020-05-22"</span></span><br><span class="line"></span><br><span class="line">RUN /bin/bash -c <span class="string">"apt-get update; \\</span></span><br><span class="line"><span class="string">apt-get install openssh-server -y; \\</span></span><br><span class="line"><span class="string">mkdir -p /var/run/sshd; \\</span></span><br><span class="line"><span class="string">sed -ri '/session    required/s%^%# %g' /etc/pam.d/sshd; \\</span></span><br><span class="line"><span class="string">rm -rf /var/lib/apt/lists/*"</span></span><br><span class="line"></span><br><span class="line">ADD authorized_keys /root/.ssh/</span><br><span class="line"></span><br><span class="line">EXPOSE 22</span><br><span class="line"></span><br><span class="line">CMD /usr/sbin/sshd -D</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="4-创建镜像"><a href="#4-创建镜像" class="headerlink" title="4. 创建镜像"></a>4. 创建镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubuntu-sshd:1.0.0 .</span><br></pre></td></tr></table></figure>

<h3 id="5-运行容器"><a href="#5-运行容器" class="headerlink" title="5. 运行容器"></a>5. 运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 30022:22 ubuntu-sshd:1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="6-连接测试"><a href="#6-连接测试" class="headerlink" title="6. 连接测试"></a>6. 连接测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 127.0.0.1 -p 30022 -o StrictHostKeyChecking=no</span><br></pre></td></tr></table></figure>

<h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><h3 id="1-创建-ubuntu-sshd-工作目录-1"><a href="#1-创建-ubuntu-sshd-工作目录-1" class="headerlink" title="1. 创建 ubuntu_sshd 工作目录"></a>1. 创建 ubuntu_sshd 工作目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir centos-sshd</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$_</span></span><br></pre></td></tr></table></figure>

<h3 id="2-配置-ssh-授权密钥文件-1"><a href="#2-配置-ssh-授权密钥文件-1" class="headerlink" title="2. 配置 ssh 授权密钥文件"></a>2. 配置 ssh 授权密钥文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ -f ~/.ssh/id_rsa ] || ssh-keygen -t rsa -f ~/.ssh/id_rsa -N <span class="string">''</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt; authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="3-编写-Dockerfile-1"><a href="#3-编写-Dockerfile-1" class="headerlink" title="3. 编写 Dockerfile"></a>3. 编写 Dockerfile</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">FROM centos:latest</span><br><span class="line"></span><br><span class="line">LABEL version=<span class="string">"1.0.0"</span> author=<span class="string">"Alan"</span> date=<span class="string">"2020-05-22"</span></span><br><span class="line"></span><br><span class="line">RUN /bin/bash -c <span class="string">'yum install openssh-server -y; \\</span></span><br><span class="line"><span class="string">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""; \\</span></span><br><span class="line"><span class="string">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""; \\</span></span><br><span class="line"><span class="string">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""; \\</span></span><br><span class="line"><span class="string">yum clean all'</span></span><br><span class="line"></span><br><span class="line">ADD authorized_keys /root/.ssh/</span><br><span class="line"></span><br><span class="line">EXPOSE 22</span><br><span class="line"></span><br><span class="line">CMD /usr/sbin/sshd -D</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="4-创建镜像-1"><a href="#4-创建镜像-1" class="headerlink" title="4. 创建镜像"></a>4. 创建镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t centos-sshd:1.0.0 .</span><br></pre></td></tr></table></figure>

<h3 id="5-运行容器-1"><a href="#5-运行容器-1" class="headerlink" title="5. 运行容器"></a>5. 运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 20022:22 centos-sshd:1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="6-连接测试-1"><a href="#6-连接测试-1" class="headerlink" title="6. 连接测试"></a>6. 连接测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 127.0.0.1 -p 20022 -o StrictHostKeyChecking=no</span><br></pre></td></tr></table></figure>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/01/Kubernetes%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">二进制部署 kubernetes 集群</div></div></a></div><div class="next-post pull_right"><a href="/2019/03/20/Python%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Python 基础入门</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ALAN</div><div class="footer_custom_text">yuiya@yahoo.com</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode far fa-sun" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>